<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
                    cookie-parser库:
                        这个库是专门用来处理cookie的,它是在express库的基础上的,使用必须在使用express库,上使用。

                    安装: 
                      npm install cookie-parser
                    
                    使用: 
                      这个库导出一个 cookieParser函数, 执行该函数会返回一个函数,这个返回的函数就是一个中间件函数。
                      这个中间件函数里面往形参注入属性:
                             形参req对象中注入cookies属性,用于获取所有请求传递过来的cookie。
                             形参res对象中注入cookie方法,用于设置cookie。
                        并且自动中间函数将形参对象注入属性后会执行next函数提交给后续的中间件函数,因为前面的req和res对象
                        已经注入了与cookie相关的属性,所以express执行后续中间件函数传入进去的res和req对象就会有前面cookie中间件函数注入的属性。
                
                    注入后res对象里的cookie方法: 
                            传三个实参: 第一个为 'key键', 第二个为 'value值', 第三个为 配置对象
                            配置对象里的属性: 
                                 cookie相关的属性:对应的值
                                 其中这里的maxAge属性的值是以豪秒的。
                      执行这个cookie函数后会往响应头添加cookie属性。


                    加密: 
                      导出的cookieParser函数可以传参数 为字符串  当做密钥,用来加密和解密
                        这个库会自动加密和解密。

                       加密: 
                         必须在执行res对象中cookie函数时,传参的第三个实参配置对象里,配置属性 signed:true 表示加密,第二个实参'value值'
                       
                       解密: 
                         当请求发过来时,不会将请求头的cookie的'value值'注入到 cookies对象中,而是注入到signedCookies中。

                     相当于cookieParser函数有传参数,用加密和解密的方式来,没有就用正常的方式来。
             //=================================================================================//

                    path-to-regexp库: 这个库是专门用来处理路径的,相当于根据路径来得出路径的正则表达式。
                    
                    安装: 
                      npm install path-to-regexp

                    使用: 
                      这个库导出一个对象,对象里面有一个 pathToRegexp函数。
                      这个pathToRegexp函数 传入一个参数为“路径” 会根据路径返回一个正则表达式,这个正则表达式跟路径参数匹配。
                      如: 参数为 /abc/vcb/:id 
                          会得出一个 正则表达式,id变成匹配所有字符。



             //=================================================================//
               
                   浏览器中会自动操作cookie,但是其他客户端不会自动操作cookie,所以
                   在 响应头中多添加一个属性: 
                                 authorization:跟cookie的值一样





           //============================================================//
                 
                   对称加密算法: aes 算法
                       要有一个密钥为: 16字节的字符串, 相当于一个长度为16的字符串,但不能有中文,因为中文占两位。
                       

                       还需要准备一个iv,随机向量。多少字节都可以,但必须是字符串。

                       在node的内置库中,有一个内置库 crypto,这个库导出一个obj,这库专门用来解密和解密。
                         在导出的对象中的属性:  加密算法一般为 'aes-128-cbc'
                                   createCipheriv('以哪种加密算法',密钥,iv向量)    这个函数用来返回加密对象

                                   createDecipheriv('以哪种解密算法',密钥,iv向量)   这个函数用来返回解密对象

                            
                            createCipheriv函数返回一个Cipheriv对象,这个对象里的属性一般都用来加密数据。
                                Cipheriv对象里的属性: 
                                          update(要加密的数据,'要加密数据的编码类型','加密后以什么编码类型返回')
                                              这个函数返回一个加密后的数据
                                          
                                          final('数据以什么编码类型输出')  这个返回的参数必须跟update函数的最后一个参数一样。
                                              这个函数返回一个加密后的数据,必须拼接在update函数返回的数据后面,才形成一个完整的加密数据。

                                  加密数据的编码类型一般为: 'utf-8'
                                  加密后要输出的编码类型一般为: 16进制,也就是 'hex'
                                              


                            createDecipheriv函数返回一个Decipheriv对象,这个对象里的属性一般都用来解密,加密后的数据。
                                Decipheriv对象里的属性: 
                                          update(要解密的数据,'要解密数据的编码类型','解密后以什么编码类型返回')
                                             这个函数返回一个解密后的数据
                                  
                                          final('数据以什么编码类型输出')  这个返回的参数必须跟update函数的最后一个参数一样。
                                              这个函数返回一个解密后的数据,必须拼接在update函数返回的数据后面,才形成一个完整的解密后的数据。


                         由于算法属于密码学:所以不用知道原理。
                                                         
                           

            
                    
                    

                 
                              
        
        
        */
    </script>
</body>

</html>