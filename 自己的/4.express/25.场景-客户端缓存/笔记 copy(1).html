<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /* 
                     
                缓存的基本原理: 
                     服务器缓存 -- 服务器会将一些常用的读取结果保存在内存中,从而减少对数据库或文件的读取。
                                  当这些简单常用的请求 请求的模块 自己内定的。

                     客户端缓存: 
                        就是将某一次请求的响应结果保存在客户端(比如浏览器)中,而后续的请求仅需要从缓存中读取即可,可
                        以极大的降低了服务器的处理压力。

                        缓存策略的问题: 
                          1.哪些资源需要加入到缓存,哪些不需要？
                          2.缓存的时间是多久
                          3.如果服务器的资源有改动,客户端该如何更新缓存呢
                          4如果缓存过期了,可是服务器上的资源并没有发生变动,该如何处理
                          等等

                        http的缓存协议: 
                          来自服务器的缓存指令: 
                            当客户端发出一个 get 请求到服务器,服务器可能会有以下的“内心”活动: 
                              你请求的这资源,我很少会改动它,你干脆把它缓存起来。

                            为了实现这个“内心”活动,服务器会给这种符合条件的请求发回响应时,在响应头中添加以下内容: 
                               Cache-Control: max-age=3600 //希望你把这个资源缓存起来,缓存事件为3600秒,也就是一个钟头
                               ETag: W/"121-171ca289ebf" //这个资源的编号是 W/"121-171ca289ebf",资源编号服务器是根据 响应体 进行编码得出的,如果响应体发生改动,再进行编码也会发生变化。
                               Date: Thu, 30 Apr 2020 12:39:56 GMT //给客户端响应这个资源的服务器时间是 全球时间xxxx
                               Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT //这个资源的上一次修改时间是 全球时间xxxx
                            如果客户端是其他应用程序,可能并不会理会服务器的响应头的这些东西,也就是不会缓存这个请求的响应的结果。
                            而如果客户端是一个浏览器,看到有这些响应头时会做出以下操作: 
                                浏览器把这次请求得到的响应体缓存到本地文件中。
                                浏览器标记这次请求的请求方法和路径(也就是url地址端口号后面的整段路径)。
                                浏览器标记这次缓存的时间是3600秒。
                                浏览器记录服务器的响应时间。
                                浏览器记录服务器的响应头中的资源编号。
                                浏览器记录Last-Modified的时间。
                              这些记录为以后浏览器要不要去请求服务器提供了各种依据。


                          来自客户端的缓存指令: 
                            当客户端准备再次请求 与上次同个相同的请求方法和路径时, 客户端会到缓存中寻找是否有缓存资源。
                              过程如下: 
                               1.缓存中是否有匹配的请求方法和路径。
                               2.如果有,该缓存资源是否以过期。

                              如果匹配得到请求方法和路径相同--会再继续判断缓存是否有效,如果有效---则使用缓存的资源。
                              如果匹配失败则发送请求到服务器(为普通请求)
                              如果缓存已经失效,会带着有缓存的请求发送到服务器(为带着缓存的请求)

                                如何验证缓存是否有效: 
                                  把 max-age + Date, 得到一个过期时间,看看这个过期时间是否大于当前时间,如果是,则表示缓存没有过期,如果不是,则缓存已经过期。

                              缓存有效: 
                                 当浏览器发现缓存有效时,完全不会请求服务器,直接使用缓存的结果
                                 这种情况下断开网络,资源仍然可用。
                                 这种情况会极大的降低服务器压力，但当服务器更改了资源后，浏览器是不知道的，只要缓存有效，它就会直接使用缓存

                              缓存无效: 
                                 当浏览器发现缓存已经过期,并不会把缓存删了,而是再次请求服务器,这个缓存还能不能使用。
                                 这个请求会,请求头会有: 
                                                If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT
                                                If-None-Match: W/"121-171ca289ebf"
                                  这个两个信息就是要让服务器来根据这两个信息来验证,缓存是否有效。
                                  之所以要发两个信息，是为了兼容不同的服务器，因为有些服务器只认If-Modified-Since，有些服务器只认If-None-Match，有些服务器两个都认。
                                  只要服务器发现请求头有这两个属性,或者其中一个就会进行验证。
                                    服务器验证可能会产生两个情况: 
                                          缓存已经无效: 
                                              服务器再次给予一个正常的响应（响应码200 带响应体），同时可以附带上新的缓存指令。
                                              这样一来，客户端就会重新缓存新的内容。

                                          缓存仍然有效: 
                                              服务器会发回响应: 
                                                 响应码为304 Not Modified
                                                 无响应体
                                                 响应头带上新的缓存指令
                                              这样一样,客户端使用缓存的资源了。
                                          客户端会重新更新缓存指令。

                        
                           
                        细节: 
                          Cache-Control
                            在这个属性中可以设置下面一个或多个值:
                            public: 指示服务器资源是公开的,这个值对于浏览器而言没有意义
                            private: 指示服务器资源是私有的,这个值对于浏览器而言没有意义
                            no-cache: 告知客户端,可以缓存这个资源,但不要直接使用缓存的,要每次都发送带一个缓存指令的请求。
                            no-store: 告知客户端，不要对这个资源做任何的缓存
                          
                          Expire
                            请看课件

                          记录缓存时的有效期
                            浏览器会按照服务器响应头的要求,自动记录缓存到本地文件,并设置各种相关信息。
                            在这些信息中,有效期特别重要,浏览器会根据服务器的响应情况,设置不同的有效期。
                            有效期设置流程: 
                               判断响应头有没有 max-age  ---有--- 判断有没有Date字段 ---有--- 过期时间为 Date + max-age
                               没有max-age,判断有没有Last-Modified字段 ---有--- 过期时间为: 当前时间 - Last-Modified / 10 作为max-age
                               没有 max-age也没有Last-Modified 则不缓存
                               没有Date字段 过期时间为: 当前时间 + max-age
                               当max-age设置为0时，缓存立即过期
                               虽然立即过期，但缓存仍然被记录下来，后续的请求通过缓存指令发送到服务器，来确认资源是否被更改。
                               因此，Cache-Control: max-age=0类似于Cache-Control: no-cache
                               详情看课件
                          
                          Pragma
                            这是http1.0版本的消息头
                            在请求时,可以添加这个属性且值为 no-cache ,则向服务器表达:不要考虑任何缓存,直接给一个结果。
                            也可以在http1.1版本中,在请求头添加 Cache-Control: no-cache, 实现同样的含义。
                            详情看课件

                          使用版本好或hash
                            hash方式: 
                            如果是使用基于webpack搭建的工程,会使用 hash的形式命名文件名,这样客户端就可以大胆使用缓存,
                            因为当文件发生内容发生变动时,hash会改变,这样,客户端请求页面时,标签的src链接到文件也会发生改变,请求是就无法匹配到缓存。
                            
                            版本号的方式: 
                            如: <link href="/xx?v=1.0.0">
                                缓存的路径是: /xx?v=1.0.0
                              当服务器的对应文件内容发生变化时,改动路径中的版本 如: /xxx?v=1.0.1
                               这样请求页面时,标签中的链接地址也发生改变,就无法匹配到缓存资源。

                            当上面的所有前提是,响应给页面的响应头的属性Cache-Control的值是no-cache,或者max-age属性值是0。

                                              
                express库: 这个处理请求的库有对http缓存协议,做出了默认的配置。
                    在这个库导出的 express对象中的属性: 
                      static('目录',配置对象)函数    这个函数返回一个获取静态资源的中间件函数。
                        可以传一个配置对象作为第二个参数,对缓存指令进行配置,如果配置了缓存指令对应的属性,会修改缓存指令对应属性的默认值,否则则使用默认值。
                       配置对象里的属性: 
                            maxAge:毫秒
                            setHeaders:function(res,path,stat){
                               res:响应对象
                               path:请求的文件在服务器中的绝对路径
                               stat:请求的,文件的对象(文件对象)
                            }
                            其属性他看文档

                
              其他内容请看课件,课件特别详细


    */
  </script>
</body>

</html>